export const scope = {

    // 作用域链
    chain,

    // 闭包
    closure,
}

/**
 * JavaScript 的作用域链（Scope Chain）是指在函数嵌套结构中，每个执行上下文的变量对象（VO）及其对应的外部环境的集合。
 * 作用域链的形成是由 JavaScript 的词法作用域规则所决定的，即变量的作用域是在代码书写阶段就已经确定的，而不是在运行时确定的。
 */

/**
 * 在 JavaScript 中，变量查找遵循作用域链的规则。当代码在某个作用域中访问一个变量时，JavaScript 引擎会按照以下顺序查找变量：
 * 当前作用域：首先查找当前函数内部的变量，如果找到则直接使用。
 * 外部作用域：如果在当前作用域中找不到该变量，则继续向外部作用域（词法上的外部）查找，直到找到该变量或者抵达全局作用域为止。
 * 这意味着，如果当前作用域中已经定义了一个变量，JavaScript 引擎会优先使用当前作用域中的变量，而不是向外部作用域查找同名变量。这就是所谓的“就近原则”。
 */

// 作用域链：作用域8 -> 作用域7 -> 作用域6 -> 作用域5 -> 作用域4 -> 作用域3 -> 作用域2 -> 作用域1 -> 作用域0

function chain(){

    let msg = "作用域-1 msg";

    (()=>{

        // 作用域0
        let hello = "作用域0 hello";
        console.log(hello);  // 输出：作用域0 hello
    
        function first(){
            // 作用域1
            function second(){
                // 作用域2
                function third(){
                    let number = 123456789;  // 作用域3
                    function fourth(){
                        // 作用域4
                        console.log(hello);  // 输出：作用域0 hello
                        
                        function fifth(){
                            // 作用域5
                            let hello = "作用域5 hello";
                            console.log(msg);
                            
                            function sixth(){
                                // 作用域6
                                function seventh(){
                                    // 作用域7
                                    function eighth(){
                                        // 作用域8
                                        console.log(hello);  // 输出：作用域5 hello
                                    }
                                    eighth();  // 调用作用域8中的函数
                                }
                                seventh();  // 调用作用域7中的函数
                            }
                            sixth();  // 调用作用域6中的函数
                        }
                        fifth();  // 调用作用域5中的函数
                    }
                    fourth();  // 调用作用域4中的函数
                }
                third();  // 调用作用域3中的函数
            }
            second();  // 调用作用域2中的函数
        }
        first();  // 调用作用域1中的函数
    
    })();

}


/**
 * 闭包(作用域链的应用)
 * 内部函数可以访问其所在外部函数中声明的变量，即使外部函数已经执行完毕，这种能力称为闭包。
 * 当函数执行时，会创建一个执行环境（包括变量对象、作用域链等），当内部函数引用了外部函数的变量时，这些变量会被保存在内部函数的作用域链中，即使外部函数执行完毕后，这些变量也不会被释放。
 * 每次外部函数被调用时，都会创建一个新的闭包，它们共享同一个函数定义，但拥有不同的作用域链和变量实例。
 */

/**
 * 闭包（Closure）是一个重要的编程概念，特别是在函数式编程中被广泛应用。理解闭包可以分为以下几个方面：
 * 
 * 定义和特性：
 * 闭包指的是函数和其相关的引用环境组合而成的实体。闭包使函数可以访问其词法作用域外部的变量。
 * 闭包允许函数在定义时捕获其所在的词法作用域，这意味着函数可以在其定义的词法作用域之外执行，并且仍然可以访问定义时的词法作用域中的变量。
 * 
 * 实际应用：
 * 保持状态：闭包可以用来维持函数的状态，使得函数每次调用时可以记住上一次调用时的状态。
 * 封装：通过闭包，可以实现模块化和封装，将变量和函数封装在私有作用域内，只暴露必要的接口。
 * 回调和异步操作：在事件处理、定时器、Ajax 请求等异步操作中，闭包可以用来保存状态或者确保回调函数能访问到正确的变量。
 * 
 * 基本构成：
 * 闭包由两部分组成：函数本身以及函数外部的词法环境（即创建函数时所处的作用域）。这个环境包含了所有在函数内部和外部声明的变量。
 * 当函数执行时，即使函数定义的地方已经离开了作用域，它仍然能够访问和操作这个环境中的变量。
 * 
 */

function closure(){
    function makeCounter() {
        let count = 0;
        return function() {
            return count++; // 返回并递增 count 的值
        };
    }
    
    // 两个闭包环境，相互独立
    let counter1 = makeCounter();
    let counter2 = makeCounter();
    
    window.setInterval(()=>{
        console.log("计数器1 = "+counter1());
    },1000);
    
    window.setInterval(()=>{
        console.log("计数器2 = "+counter2());
    },2000);
}

/**
 * 在非模块化的 JavaScript 文件中，所有的代码都共享同一个全局作用域
 * 这意味着所有的全局变量、函数和对象都属于同一个全局命名空间，因此容易导致全局污染的问题
 * 
 * ES6 模块化的 JavaScript 文件，每个 ES6 模块都有自己的模块作用域。
 * 模块内部定义的变量和函数默认是私有的，除非显式地导出（export）它们，其他模块才能通过导入（import）的方式访问这些变量和函数。
 */